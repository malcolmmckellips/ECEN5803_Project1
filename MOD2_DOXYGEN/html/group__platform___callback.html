<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Module 2: Callback class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Module 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__platform___callback.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Callback class<div class="ingroups"><a class="el" href="group__platform.html">Platform</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback&lt; F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_08_4.html">mbed::Callback&lt; R(A0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_08_4.html">mbed::Callback&lt; R(A0, A1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_08_4.html">mbed::Callback&lt; R(A0, A1, A2)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_00_01_a4_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4162849f549ae66f75bd485b81ab53fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MBED_ENABLE_IF_CALLBACK_COMPATIBLE</b>(F,  M)</td></tr>
<tr class="separator:ga4162849f549ae66f75bd485b81ab53fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memItemLeft" align="right" valign="top"><a id="ga8c554e299aa26216c4c34d9d822b05f8"></a>
typedef <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void(int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::event_callback_t</b></td></tr>
<tr class="separator:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga996d0526ad2417ca8568c2ee02fda826"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga996d0526ad2417ca8568c2ee02fda826"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga996d0526ad2417ca8568c2ee02fda826">mbed::callback</a> (R(*func)()=0)</td></tr>
<tr class="separator:ga996d0526ad2417ca8568c2ee02fda826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22222b3867965d7262bb06956b804f2d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga22222b3867965d7262bb06956b804f2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga22222b3867965d7262bb06956b804f2d">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;func)</td></tr>
<tr class="separator:ga22222b3867965d7262bb06956b804f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cea788b66e91cada7e2d349b7aac208"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga4cea788b66e91cada7e2d349b7aac208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga4cea788b66e91cada7e2d349b7aac208">mbed::callback</a> (U *obj, R(T::*method)())</td></tr>
<tr class="separator:ga4cea788b66e91cada7e2d349b7aac208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ebbe050ad4118e72b30c4f1807d5be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gaf9ebbe050ad4118e72b30c4f1807d5be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaf9ebbe050ad4118e72b30c4f1807d5be">mbed::callback</a> (const U *obj, R(T::*method)() const)</td></tr>
<tr class="separator:gaf9ebbe050ad4118e72b30c4f1807d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a4bb836fb071ff9b2312ea091b868b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga76a4bb836fb071ff9b2312ea091b868b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga76a4bb836fb071ff9b2312ea091b868b">mbed::callback</a> (volatile U *obj, R(T::*method)() volatile)</td></tr>
<tr class="separator:ga76a4bb836fb071ff9b2312ea091b868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c6d0163ac9b65152cc9ad8b260a6d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga02c6d0163ac9b65152cc9ad8b260a6d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga02c6d0163ac9b65152cc9ad8b260a6d5">mbed::callback</a> (const volatile U *obj, R(T::*method)() const volatile)</td></tr>
<tr class="separator:ga02c6d0163ac9b65152cc9ad8b260a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d154416d8e52a8193382036cc7aa742"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga4d154416d8e52a8193382036cc7aa742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga4d154416d8e52a8193382036cc7aa742">mbed::callback</a> (R(*func)(T *), U *arg)</td></tr>
<tr class="separator:ga4d154416d8e52a8193382036cc7aa742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56268c6396e3d47a76b4c42baf965601"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga56268c6396e3d47a76b4c42baf965601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga56268c6396e3d47a76b4c42baf965601">mbed::callback</a> (R(*func)(const T *), const U *arg)</td></tr>
<tr class="separator:ga56268c6396e3d47a76b4c42baf965601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8b19fe7f922083f525c84bce6b21158"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gac8b19fe7f922083f525c84bce6b21158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gac8b19fe7f922083f525c84bce6b21158">mbed::callback</a> (R(*func)(volatile T *), volatile U *arg)</td></tr>
<tr class="separator:gac8b19fe7f922083f525c84bce6b21158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382ecc6c52a0c742f0fb4720275613db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga382ecc6c52a0c742f0fb4720275613db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga382ecc6c52a0c742f0fb4720275613db">mbed::callback</a> (R(*func)(const volatile T *), const volatile U *arg)</td></tr>
<tr class="separator:ga382ecc6c52a0c742f0fb4720275613db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga598e97b15c4d90f94aa1d1668d5cdcd0">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R()&gt; callback(U *obj</td></tr>
<tr class="separator:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea9cb7224935448840ac00a3898348f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gafea9cb7224935448840ac00a3898348f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gafea9cb7224935448840ac00a3898348f">mbed::callback</a> (R(*func)(A0)=0)</td></tr>
<tr class="separator:gafea9cb7224935448840ac00a3898348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59b0caef39e08b34515877ccb3150fe"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gab59b0caef39e08b34515877ccb3150fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gab59b0caef39e08b34515877ccb3150fe">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;func)</td></tr>
<tr class="separator:gab59b0caef39e08b34515877ccb3150fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faf8c21abf5a13c7a111e4dcf6ad9ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga6faf8c21abf5a13c7a111e4dcf6ad9ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga6faf8c21abf5a13c7a111e4dcf6ad9ba">mbed::callback</a> (U *obj, R(T::*method)(A0))</td></tr>
<tr class="separator:ga6faf8c21abf5a13c7a111e4dcf6ad9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332bc93ded517caa2bf2c19ad6b08240"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga332bc93ded517caa2bf2c19ad6b08240"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga332bc93ded517caa2bf2c19ad6b08240">mbed::callback</a> (const U *obj, R(T::*method)(A0) const)</td></tr>
<tr class="separator:ga332bc93ded517caa2bf2c19ad6b08240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337024fec70cc2de2f3ec8e2403f946f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga337024fec70cc2de2f3ec8e2403f946f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga337024fec70cc2de2f3ec8e2403f946f">mbed::callback</a> (volatile U *obj, R(T::*method)(A0) volatile)</td></tr>
<tr class="separator:ga337024fec70cc2de2f3ec8e2403f946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde336af6e9364b45d37996061ec7f8c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gadde336af6e9364b45d37996061ec7f8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gadde336af6e9364b45d37996061ec7f8c">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0) const volatile)</td></tr>
<tr class="separator:gadde336af6e9364b45d37996061ec7f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa3371f0474eb6ee3958465b6190701"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga3fa3371f0474eb6ee3958465b6190701"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga3fa3371f0474eb6ee3958465b6190701">mbed::callback</a> (R(*func)(T *, A0), U *arg)</td></tr>
<tr class="separator:ga3fa3371f0474eb6ee3958465b6190701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fa72855854803087daa775b07c9b26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gac6fa72855854803087daa775b07c9b26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gac6fa72855854803087daa775b07c9b26">mbed::callback</a> (R(*func)(const T *, A0), const U *arg)</td></tr>
<tr class="separator:gac6fa72855854803087daa775b07c9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf20dafacd0dde1c59c91897378467ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gadf20dafacd0dde1c59c91897378467ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gadf20dafacd0dde1c59c91897378467ce">mbed::callback</a> (R(*func)(volatile T *, A0), volatile U *arg)</td></tr>
<tr class="separator:gadf20dafacd0dde1c59c91897378467ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41cf8e0d3a19afe5f8743302806d5b16"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga41cf8e0d3a19afe5f8743302806d5b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga41cf8e0d3a19afe5f8743302806d5b16">mbed::callback</a> (R(*func)(const volatile T *, A0), const volatile U *arg)</td></tr>
<tr class="separator:ga41cf8e0d3a19afe5f8743302806d5b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga301526d02ad11b9014ffd1e03bc577b9">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0)&gt; callback(U *obj</td></tr>
<tr class="separator:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e827139f0c898e7b86386d89034dd3a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga3e827139f0c898e7b86386d89034dd3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga3e827139f0c898e7b86386d89034dd3a">mbed::callback</a> (R(*func)(A0, A1)=0)</td></tr>
<tr class="separator:ga3e827139f0c898e7b86386d89034dd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a05df6c20b0f284975f7e6d8c139a1d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga7a05df6c20b0f284975f7e6d8c139a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga7a05df6c20b0f284975f7e6d8c139a1d">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;func)</td></tr>
<tr class="separator:ga7a05df6c20b0f284975f7e6d8c139a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa606203f73fbb19501d2dda764b3ac9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gaaa606203f73fbb19501d2dda764b3ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaaa606203f73fbb19501d2dda764b3ac9">mbed::callback</a> (U *obj, R(T::*method)(A0, A1))</td></tr>
<tr class="separator:gaaa606203f73fbb19501d2dda764b3ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dfe1a4167d45a18e7a613e61097c410"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga5dfe1a4167d45a18e7a613e61097c410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga5dfe1a4167d45a18e7a613e61097c410">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1) const)</td></tr>
<tr class="separator:ga5dfe1a4167d45a18e7a613e61097c410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02acf9c71c372d9eff7455f206cc2c03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga02acf9c71c372d9eff7455f206cc2c03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga02acf9c71c372d9eff7455f206cc2c03">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1) volatile)</td></tr>
<tr class="separator:ga02acf9c71c372d9eff7455f206cc2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4437cfa57a090824e1779d592a1def8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gae4437cfa57a090824e1779d592a1def8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae4437cfa57a090824e1779d592a1def8">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1) const volatile)</td></tr>
<tr class="separator:gae4437cfa57a090824e1779d592a1def8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd37e1af84743f56970ad71fcd67431"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga8bd37e1af84743f56970ad71fcd67431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga8bd37e1af84743f56970ad71fcd67431">mbed::callback</a> (R(*func)(T *, A0, A1), U *arg)</td></tr>
<tr class="separator:ga8bd37e1af84743f56970ad71fcd67431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaabfdf0aa0c549570940200eb2a63614"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gaaabfdf0aa0c549570940200eb2a63614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaaabfdf0aa0c549570940200eb2a63614">mbed::callback</a> (R(*func)(const T *, A0, A1), const U *arg)</td></tr>
<tr class="separator:gaaabfdf0aa0c549570940200eb2a63614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf352333ac65f8f6e01afb997f2d244d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gaf352333ac65f8f6e01afb997f2d244d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaf352333ac65f8f6e01afb997f2d244d0">mbed::callback</a> (R(*func)(volatile T *, A0, A1), volatile U *arg)</td></tr>
<tr class="separator:gaf352333ac65f8f6e01afb997f2d244d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7447f4b253bc2dcf50daf68896780a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga8d7447f4b253bc2dcf50daf68896780a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga8d7447f4b253bc2dcf50daf68896780a">mbed::callback</a> (R(*func)(const volatile T *, A0, A1), const volatile U *arg)</td></tr>
<tr class="separator:ga8d7447f4b253bc2dcf50daf68896780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga44f9e781941d03580345c71175307b53">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga44f9e781941d03580345c71175307b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memItemLeft" align="right" valign="top"><a id="ga6a79d55a32e1d1ae294e9b3d3b72c823"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1))</td></tr>
<tr class="separator:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdb16e4589e501b95b00aa6404046f4"><td class="memItemLeft" align="right" valign="top"><a id="gabbdb16e4589e501b95b00aa6404046f4"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1))</td></tr>
<tr class="separator:gabbdb16e4589e501b95b00aa6404046f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memItemLeft" align="right" valign="top"><a id="ga6e6268b0371ee9d06de1ecb0871c7415"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1))</td></tr>
<tr class="separator:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memItemLeft" align="right" valign="top"><a id="ga86fe08eb53a158beb1422d0cf86cb855"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1))</td></tr>
<tr class="separator:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa250c9b310dac34abe3533d5525f4ea"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gafa250c9b310dac34abe3533d5525f4ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gafa250c9b310dac34abe3533d5525f4ea">mbed::callback</a> (R(*func)(A0, A1, A2)=0)</td></tr>
<tr class="separator:gafa250c9b310dac34abe3533d5525f4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa603f032284f816a0f04a2949cdc9e2c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gaa603f032284f816a0f04a2949cdc9e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaa603f032284f816a0f04a2949cdc9e2c">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;func)</td></tr>
<tr class="separator:gaa603f032284f816a0f04a2949cdc9e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d37664f3e753abbb553c88be75ac984"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga2d37664f3e753abbb553c88be75ac984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga2d37664f3e753abbb553c88be75ac984">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2))</td></tr>
<tr class="separator:ga2d37664f3e753abbb553c88be75ac984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec3a270f36ca5b4840d516f51cc462ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gaec3a270f36ca5b4840d516f51cc462ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaec3a270f36ca5b4840d516f51cc462ea">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2) const)</td></tr>
<tr class="separator:gaec3a270f36ca5b4840d516f51cc462ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5c290651bd0eccfd729ce99e5da139"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gacd5c290651bd0eccfd729ce99e5da139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gacd5c290651bd0eccfd729ce99e5da139">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2) volatile)</td></tr>
<tr class="separator:gacd5c290651bd0eccfd729ce99e5da139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b2c58ee5e3165819d5e5a61da16198"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga02b2c58ee5e3165819d5e5a61da16198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga02b2c58ee5e3165819d5e5a61da16198">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2) const volatile)</td></tr>
<tr class="separator:ga02b2c58ee5e3165819d5e5a61da16198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559b6aeea913f16298dbe59cb52b0c4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga559b6aeea913f16298dbe59cb52b0c4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga559b6aeea913f16298dbe59cb52b0c4f">mbed::callback</a> (R(*func)(T *, A0, A1, A2), U *arg)</td></tr>
<tr class="separator:ga559b6aeea913f16298dbe59cb52b0c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fc85eb356a6826e1f814b5bbd11cc9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga67fc85eb356a6826e1f814b5bbd11cc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga67fc85eb356a6826e1f814b5bbd11cc9">mbed::callback</a> (R(*func)(const T *, A0, A1, A2), const U *arg)</td></tr>
<tr class="separator:ga67fc85eb356a6826e1f814b5bbd11cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe54eed363fa45c26833d959e8a0475"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga1fe54eed363fa45c26833d959e8a0475"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1fe54eed363fa45c26833d959e8a0475">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2), volatile U *arg)</td></tr>
<tr class="separator:ga1fe54eed363fa45c26833d959e8a0475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426d9f904576d4d8c8ec225f98962aee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga426d9f904576d4d8c8ec225f98962aee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga426d9f904576d4d8c8ec225f98962aee">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2), const volatile U *arg)</td></tr>
<tr class="separator:ga426d9f904576d4d8c8ec225f98962aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga10bb79c4ef863bc9917cbf446d7d0568">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd464801649c6ff71316ed2373a66f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7fd464801649c6ff71316ed2373a66f1"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2))</td></tr>
<tr class="separator:ga7fd464801649c6ff71316ed2373a66f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd770ad119c87748e4ed14af62840a3c"><td class="memItemLeft" align="right" valign="top"><a id="gabd770ad119c87748e4ed14af62840a3c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2))</td></tr>
<tr class="separator:gabd770ad119c87748e4ed14af62840a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memItemLeft" align="right" valign="top"><a id="ga1eb0875e7ccc615234c1179bf5ef9907"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memItemLeft" align="right" valign="top"><a id="ga415e35bf19000e3e1a297e2b6dd4c33c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b95f8dfc61206d7640ab689313f251"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae2b95f8dfc61206d7640ab689313f251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae2b95f8dfc61206d7640ab689313f251">mbed::callback</a> (R(*func)(A0, A1, A2, A3)=0)</td></tr>
<tr class="separator:gae2b95f8dfc61206d7640ab689313f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d19e959d0b664cd130e03391a8484e3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga0d19e959d0b664cd130e03391a8484e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga0d19e959d0b664cd130e03391a8484e3">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;func)</td></tr>
<tr class="separator:ga0d19e959d0b664cd130e03391a8484e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fba04d1f4096eca65d80ead0737c154"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga9fba04d1f4096eca65d80ead0737c154"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9fba04d1f4096eca65d80ead0737c154">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3))</td></tr>
<tr class="separator:ga9fba04d1f4096eca65d80ead0737c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa461cc7a6bb990b1583e8bf1110a58ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gaa461cc7a6bb990b1583e8bf1110a58ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaa461cc7a6bb990b1583e8bf1110a58ae">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3) const)</td></tr>
<tr class="separator:gaa461cc7a6bb990b1583e8bf1110a58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00ede4a066b7a1a9eb783a3d80708e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae00ede4a066b7a1a9eb783a3d80708e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae00ede4a066b7a1a9eb783a3d80708e9">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3) volatile)</td></tr>
<tr class="separator:gae00ede4a066b7a1a9eb783a3d80708e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0b9c8a1dbbff26aeab0d1350cadfbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gaad0b9c8a1dbbff26aeab0d1350cadfbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaad0b9c8a1dbbff26aeab0d1350cadfbc">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3) const volatile)</td></tr>
<tr class="separator:gaad0b9c8a1dbbff26aeab0d1350cadfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d3b8ff6867008d32c8e4b310e3b7b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga03d3b8ff6867008d32c8e4b310e3b7b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga03d3b8ff6867008d32c8e4b310e3b7b4">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3), U *arg)</td></tr>
<tr class="separator:ga03d3b8ff6867008d32c8e4b310e3b7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a20b73eeeb0cd0c6cf783d32ee576f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga82a20b73eeeb0cd0c6cf783d32ee576f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga82a20b73eeeb0cd0c6cf783d32ee576f">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3), const U *arg)</td></tr>
<tr class="separator:ga82a20b73eeeb0cd0c6cf783d32ee576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11756ba43a9eb9dad5f6e8867920583f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga11756ba43a9eb9dad5f6e8867920583f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga11756ba43a9eb9dad5f6e8867920583f">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3), volatile U *arg)</td></tr>
<tr class="separator:ga11756ba43a9eb9dad5f6e8867920583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dcdeddf5595e94ee59975e34666eb5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga1dcdeddf5595e94ee59975e34666eb5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1dcdeddf5595e94ee59975e34666eb5c">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3), const volatile U *arg)</td></tr>
<tr class="separator:ga1dcdeddf5595e94ee59975e34666eb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae58d69f185c10e920930a5dd1aebeca4">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:gae58d69f185c10e920930a5dd1aebeca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25161621af1037bf51ab84016adc41e6"><td class="memItemLeft" align="right" valign="top"><a id="ga25161621af1037bf51ab84016adc41e6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga25161621af1037bf51ab84016adc41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memItemLeft" align="right" valign="top"><a id="ga50fd76309106f1205f5fe8d1fb5793f8"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memItemLeft" align="right" valign="top"><a id="gae960785a3b20bb7d11aa116d2ef3159d"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memItemLeft" align="right" valign="top"><a id="ga9e9fdd9ee815f90a694fd10622729ae6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ad73cc03361b2d5a6aa0f5c8e2cf55"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga97ad73cc03361b2d5a6aa0f5c8e2cf55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga97ad73cc03361b2d5a6aa0f5c8e2cf55">mbed::callback</a> (R(*func)(A0, A1, A2, A3, A4)=0)</td></tr>
<tr class="separator:ga97ad73cc03361b2d5a6aa0f5c8e2cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63612f6a045d404bbf63b246011bebad"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga63612f6a045d404bbf63b246011bebad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga63612f6a045d404bbf63b246011bebad">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;func)</td></tr>
<tr class="separator:ga63612f6a045d404bbf63b246011bebad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabab123e6af89da5cb1189a8f1d9a320e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:gabab123e6af89da5cb1189a8f1d9a320e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gabab123e6af89da5cb1189a8f1d9a320e">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gabab123e6af89da5cb1189a8f1d9a320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e638f6a629403b0726d558a243f12c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga54e638f6a629403b0726d558a243f12c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga54e638f6a629403b0726d558a243f12c">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3, A4) const)</td></tr>
<tr class="separator:ga54e638f6a629403b0726d558a243f12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af755e55af9946b5ff6af1b47f9b97f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga5af755e55af9946b5ff6af1b47f9b97f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga5af755e55af9946b5ff6af1b47f9b97f">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) volatile)</td></tr>
<tr class="separator:ga5af755e55af9946b5ff6af1b47f9b97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e20239108ed2b55343ac73edaf80ea8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga1e20239108ed2b55343ac73edaf80ea8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1e20239108ed2b55343ac73edaf80ea8">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) const volatile)</td></tr>
<tr class="separator:ga1e20239108ed2b55343ac73edaf80ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga766b64a67eb9694410dae0415e37593e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga766b64a67eb9694410dae0415e37593e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga766b64a67eb9694410dae0415e37593e">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3, A4), U *arg)</td></tr>
<tr class="separator:ga766b64a67eb9694410dae0415e37593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07cd6c79bd7102f0b5a45aa14f29fb5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:gad07cd6c79bd7102f0b5a45aa14f29fb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gad07cd6c79bd7102f0b5a45aa14f29fb5">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3, A4), const U *arg)</td></tr>
<tr class="separator:gad07cd6c79bd7102f0b5a45aa14f29fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8b0e10a2573be5bfa56af1b942a563"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga6f8b0e10a2573be5bfa56af1b942a563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga6f8b0e10a2573be5bfa56af1b942a563">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3, A4), volatile U *arg)</td></tr>
<tr class="separator:ga6f8b0e10a2573be5bfa56af1b942a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a34a120765a2ff4d7b3300017030735"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga5a34a120765a2ff4d7b3300017030735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga5a34a120765a2ff4d7b3300017030735">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3, A4), const volatile U *arg)</td></tr>
<tr class="separator:ga5a34a120765a2ff4d7b3300017030735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga523a7324cf927bf9614efeb64c557d66">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga523a7324cf927bf9614efeb64c557d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memItemLeft" align="right" valign="top"><a id="ga07932813a1b77d4df478f3f4872cd4ff"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memItemLeft" align="right" valign="top"><a id="gaf22c19ca6c2ab41c071037ce9c42aa9d"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36a23ed73fdb64410841161f07c05dc"><td class="memItemLeft" align="right" valign="top"><a id="gab36a23ed73fdb64410841161f07c05dc"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gab36a23ed73fdb64410841161f07c05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memItemLeft" align="right" valign="top"><a id="gae34aa30f64c3b8fe0bc2d5863bb04164"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga689911b75562b995e216d5c4db982b64"><td class="memItemLeft" align="right" valign="top"><a id="ga689911b75562b995e216d5c4db982b64"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::func</b> )(T *))</td></tr>
<tr class="separator:ga689911b75562b995e216d5c4db982b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memItemLeft" align="right" valign="top"><a id="ga1039d88edb3bf471ffd231b2b9e674a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A1</b></td></tr>
<tr class="separator:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memItemLeft" align="right" valign="top"><a id="gaff8fcdfa5c88334f1e8b265c3bc39c71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A2</b></td></tr>
<tr class="separator:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memItemLeft" align="right" valign="top"><a id="gaeae6936924cb2d9e94265195d8fdb8c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A3</b></td></tr>
<tr class="separator:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4162849f549ae66f75bd485b81ab53fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4162849f549ae66f75bd485b81ab53fc">&#9670;&nbsp;</a></span>MBED_ENABLE_IF_CALLBACK_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">F, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typename</span> detail::enable_if&lt;                                             \</div>
<div class="line">            detail::is_type&lt;M, &amp;F::operator()&gt;::value &amp;&amp;                    \</div>
<div class="line">            sizeof(F) &lt;= <span class="keyword">sizeof</span>(uintptr_t)                                  \</div>
<div class="line">        &gt;::type = detail::nil()</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga22222b3867965d7262bb06956b804f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22222b3867965d7262bb06956b804f2d">&#9670;&nbsp;</a></span>callback() <span class="overload">[1/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gab59b0caef39e08b34515877ccb3150fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab59b0caef39e08b34515877ccb3150fe">&#9670;&nbsp;</a></span>callback() <span class="overload">[2/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga7a05df6c20b0f284975f7e6d8c139a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a05df6c20b0f284975f7e6d8c139a1d">&#9670;&nbsp;</a></span>callback() <span class="overload">[3/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaa603f032284f816a0f04a2949cdc9e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa603f032284f816a0f04a2949cdc9e2c">&#9670;&nbsp;</a></span>callback() <span class="overload">[4/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga0d19e959d0b664cd130e03391a8484e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d19e959d0b664cd130e03391a8484e3">&#9670;&nbsp;</a></span>callback() <span class="overload">[5/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga63612f6a045d404bbf63b246011bebad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63612f6a045d404bbf63b246011bebad">&#9670;&nbsp;</a></span>callback() <span class="overload">[6/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaf9ebbe050ad4118e72b30c4f1807d5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9ebbe050ad4118e72b30c4f1807d5be">&#9670;&nbsp;</a></span>callback() <span class="overload">[7/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga332bc93ded517caa2bf2c19ad6b08240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332bc93ded517caa2bf2c19ad6b08240">&#9670;&nbsp;</a></span>callback() <span class="overload">[8/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga5dfe1a4167d45a18e7a613e61097c410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dfe1a4167d45a18e7a613e61097c410">&#9670;&nbsp;</a></span>callback() <span class="overload">[9/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaec3a270f36ca5b4840d516f51cc462ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec3a270f36ca5b4840d516f51cc462ea">&#9670;&nbsp;</a></span>callback() <span class="overload">[10/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaa461cc7a6bb990b1583e8bf1110a58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa461cc7a6bb990b1583e8bf1110a58ae">&#9670;&nbsp;</a></span>callback() <span class="overload">[11/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga54e638f6a629403b0726d558a243f12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e638f6a629403b0726d558a243f12c">&#9670;&nbsp;</a></span>callback() <span class="overload">[12/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga02c6d0163ac9b65152cc9ad8b260a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02c6d0163ac9b65152cc9ad8b260a6d5">&#9670;&nbsp;</a></span>callback() <span class="overload">[13/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gadde336af6e9364b45d37996061ec7f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadde336af6e9364b45d37996061ec7f8c">&#9670;&nbsp;</a></span>callback() <span class="overload">[14/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae4437cfa57a090824e1779d592a1def8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4437cfa57a090824e1779d592a1def8">&#9670;&nbsp;</a></span>callback() <span class="overload">[15/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga02b2c58ee5e3165819d5e5a61da16198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b2c58ee5e3165819d5e5a61da16198">&#9670;&nbsp;</a></span>callback() <span class="overload">[16/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaad0b9c8a1dbbff26aeab0d1350cadfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0b9c8a1dbbff26aeab0d1350cadfbc">&#9670;&nbsp;</a></span>callback() <span class="overload">[17/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga1e20239108ed2b55343ac73edaf80ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e20239108ed2b55343ac73edaf80ea8">&#9670;&nbsp;</a></span>callback() <span class="overload">[18/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga996d0526ad2417ca8568c2ee02fda826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996d0526ad2417ca8568c2ee02fda826">&#9670;&nbsp;</a></span>callback() <span class="overload">[19/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gafea9cb7224935448840ac00a3898348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafea9cb7224935448840ac00a3898348f">&#9670;&nbsp;</a></span>callback() <span class="overload">[20/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga3e827139f0c898e7b86386d89034dd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e827139f0c898e7b86386d89034dd3a">&#9670;&nbsp;</a></span>callback() <span class="overload">[21/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gafa250c9b310dac34abe3533d5525f4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa250c9b310dac34abe3533d5525f4ea">&#9670;&nbsp;</a></span>callback() <span class="overload">[22/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae2b95f8dfc61206d7640ab689313f251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b95f8dfc61206d7640ab689313f251">&#9670;&nbsp;</a></span>callback() <span class="overload">[23/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga97ad73cc03361b2d5a6aa0f5c8e2cf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97ad73cc03361b2d5a6aa0f5c8e2cf55">&#9670;&nbsp;</a></span>callback() <span class="overload">[24/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga56268c6396e3d47a76b4c42baf965601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56268c6396e3d47a76b4c42baf965601">&#9670;&nbsp;</a></span>callback() <span class="overload">[25/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gac6fa72855854803087daa775b07c9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fa72855854803087daa775b07c9b26">&#9670;&nbsp;</a></span>callback() <span class="overload">[26/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaaabfdf0aa0c549570940200eb2a63614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaabfdf0aa0c549570940200eb2a63614">&#9670;&nbsp;</a></span>callback() <span class="overload">[27/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga67fc85eb356a6826e1f814b5bbd11cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fc85eb356a6826e1f814b5bbd11cc9">&#9670;&nbsp;</a></span>callback() <span class="overload">[28/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga82a20b73eeeb0cd0c6cf783d32ee576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82a20b73eeeb0cd0c6cf783d32ee576f">&#9670;&nbsp;</a></span>callback() <span class="overload">[29/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gad07cd6c79bd7102f0b5a45aa14f29fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad07cd6c79bd7102f0b5a45aa14f29fb5">&#9670;&nbsp;</a></span>callback() <span class="overload">[30/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga382ecc6c52a0c742f0fb4720275613db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382ecc6c52a0c742f0fb4720275613db">&#9670;&nbsp;</a></span>callback() <span class="overload">[31/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga41cf8e0d3a19afe5f8743302806d5b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41cf8e0d3a19afe5f8743302806d5b16">&#9670;&nbsp;</a></span>callback() <span class="overload">[32/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga8d7447f4b253bc2dcf50daf68896780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7447f4b253bc2dcf50daf68896780a">&#9670;&nbsp;</a></span>callback() <span class="overload">[33/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga426d9f904576d4d8c8ec225f98962aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426d9f904576d4d8c8ec225f98962aee">&#9670;&nbsp;</a></span>callback() <span class="overload">[34/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga1dcdeddf5595e94ee59975e34666eb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dcdeddf5595e94ee59975e34666eb5c">&#9670;&nbsp;</a></span>callback() <span class="overload">[35/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga5a34a120765a2ff4d7b3300017030735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a34a120765a2ff4d7b3300017030735">&#9670;&nbsp;</a></span>callback() <span class="overload">[36/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga4d154416d8e52a8193382036cc7aa742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d154416d8e52a8193382036cc7aa742">&#9670;&nbsp;</a></span>callback() <span class="overload">[37/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga3fa3371f0474eb6ee3958465b6190701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa3371f0474eb6ee3958465b6190701">&#9670;&nbsp;</a></span>callback() <span class="overload">[38/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga8bd37e1af84743f56970ad71fcd67431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd37e1af84743f56970ad71fcd67431">&#9670;&nbsp;</a></span>callback() <span class="overload">[39/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga559b6aeea913f16298dbe59cb52b0c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559b6aeea913f16298dbe59cb52b0c4f">&#9670;&nbsp;</a></span>callback() <span class="overload">[40/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga03d3b8ff6867008d32c8e4b310e3b7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d3b8ff6867008d32c8e4b310e3b7b4">&#9670;&nbsp;</a></span>callback() <span class="overload">[41/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga766b64a67eb9694410dae0415e37593e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga766b64a67eb9694410dae0415e37593e">&#9670;&nbsp;</a></span>callback() <span class="overload">[42/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gac8b19fe7f922083f525c84bce6b21158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8b19fe7f922083f525c84bce6b21158">&#9670;&nbsp;</a></span>callback() <span class="overload">[43/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gadf20dafacd0dde1c59c91897378467ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf20dafacd0dde1c59c91897378467ce">&#9670;&nbsp;</a></span>callback() <span class="overload">[44/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaf352333ac65f8f6e01afb997f2d244d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf352333ac65f8f6e01afb997f2d244d0">&#9670;&nbsp;</a></span>callback() <span class="overload">[45/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga1fe54eed363fa45c26833d959e8a0475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe54eed363fa45c26833d959e8a0475">&#9670;&nbsp;</a></span>callback() <span class="overload">[46/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga11756ba43a9eb9dad5f6e8867920583f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11756ba43a9eb9dad5f6e8867920583f">&#9670;&nbsp;</a></span>callback() <span class="overload">[47/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga6f8b0e10a2573be5bfa56af1b942a563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8b0e10a2573be5bfa56af1b942a563">&#9670;&nbsp;</a></span>callback() <span class="overload">[48/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga4cea788b66e91cada7e2d349b7aac208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cea788b66e91cada7e2d349b7aac208">&#9670;&nbsp;</a></span>callback() <span class="overload">[49/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga6faf8c21abf5a13c7a111e4dcf6ad9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6faf8c21abf5a13c7a111e4dcf6ad9ba">&#9670;&nbsp;</a></span>callback() <span class="overload">[50/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaaa606203f73fbb19501d2dda764b3ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa606203f73fbb19501d2dda764b3ac9">&#9670;&nbsp;</a></span>callback() <span class="overload">[51/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga2d37664f3e753abbb553c88be75ac984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d37664f3e753abbb553c88be75ac984">&#9670;&nbsp;</a></span>callback() <span class="overload">[52/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9fba04d1f4096eca65d80ead0737c154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fba04d1f4096eca65d80ead0737c154">&#9670;&nbsp;</a></span>callback() <span class="overload">[53/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gabab123e6af89da5cb1189a8f1d9a320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabab123e6af89da5cb1189a8f1d9a320e">&#9670;&nbsp;</a></span>callback() <span class="overload">[54/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga76a4bb836fb071ff9b2312ea091b868b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76a4bb836fb071ff9b2312ea091b868b">&#9670;&nbsp;</a></span>callback() <span class="overload">[55/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga337024fec70cc2de2f3ec8e2403f946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga337024fec70cc2de2f3ec8e2403f946f">&#9670;&nbsp;</a></span>callback() <span class="overload">[56/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga02acf9c71c372d9eff7455f206cc2c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02acf9c71c372d9eff7455f206cc2c03">&#9670;&nbsp;</a></span>callback() <span class="overload">[57/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gacd5c290651bd0eccfd729ce99e5da139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5c290651bd0eccfd729ce99e5da139">&#9670;&nbsp;</a></span>callback() <span class="overload">[58/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae00ede4a066b7a1a9eb783a3d80708e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae00ede4a066b7a1a9eb783a3d80708e9">&#9670;&nbsp;</a></span>callback() <span class="overload">[59/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga5af755e55af9946b5ff6af1b47f9b97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af755e55af9946b5ff6af1b47f9b97f">&#9670;&nbsp;</a></span>callback() <span class="overload">[60/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt;R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga598e97b15c4d90f94aa1d1668d5cdcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598e97b15c4d90f94aa1d1668d5cdcd0">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga44f9e781941d03580345c71175307b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f9e781941d03580345c71175307b53">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga10bb79c4ef863bc9917cbf446d7d0568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10bb79c4ef863bc9917cbf446d7d0568">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="gae58d69f185c10e920930a5dd1aebeca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58d69f185c10e920930a5dd1aebeca4">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga523a7324cf927bf9614efeb64c557d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523a7324cf927bf9614efeb64c557d66">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga301526d02ad11b9014ffd1e03bc577b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301526d02ad11b9014ffd1e03bc577b9">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p>Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
